// Code generated by dagger-compiler.  Do not edit.
package com.sjtu.icarer;

import dagger.internal.Binding;
import dagger.internal.BindingsGroup;
import dagger.internal.Linker;
import dagger.internal.ModuleAdapter;
import dagger.internal.ProvidesBinding;
import java.util.Set;
import javax.inject.Provider;

/**
 * A manager of modules and provides adapters allowing for proper linking and
 * instance provision of types served by {@code @Provides} methods.
 */
public final class AndroidModule$$ModuleAdapter extends ModuleAdapter<AndroidModule> {
  private static final String[] INJECTS = { };
  private static final Class<?>[] STATIC_INJECTIONS = { };
  private static final Class<?>[] INCLUDES = { };

  public AndroidModule$$ModuleAdapter() {
    super(com.sjtu.icarer.AndroidModule.class, INJECTS, STATIC_INJECTIONS, false /*overrides*/, INCLUDES, false /*complete*/, true /*library*/);
  }

  @Override
  public AndroidModule newModule() {
    return new com.sjtu.icarer.AndroidModule();
  }

  /**
   * Used internally obtain dependency information, such as for cyclical
   * graph detection.
   */
  @Override
  public void getBindings(BindingsGroup bindings, AndroidModule module) {
    bindings.contributeProvidesBinding("android.content.SharedPreferences", new ProvideDefaultSharedPreferencesProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.telephony.TelephonyManager", new ProvideTelephonyManagerProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.accounts.AccountManager", new ProvideAccountManagerProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.app.NotificationManager", new ProvideNotificationManagerProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.content.pm.ApplicationInfo", new ProvideApplicationInfoProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.view.inputmethod.InputMethodManager", new ProvideInputMethodManagerProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.content.Context", new ProvideAppContextProvidesAdapter(module));
    bindings.contributeProvidesBinding("java.lang.ClassLoader", new ProvideClassLoaderProvidesAdapter(module));
    bindings.contributeProvidesBinding("android.content.pm.PackageInfo", new ProvidePackageInfoProvidesAdapter(module));
  }

  /**
   * A {@code Binding<android.content.SharedPreferences>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.content.SharedPreferences} and its
   * dependencies.
   *
   * Being a {@code Provider<android.content.SharedPreferences>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideDefaultSharedPreferencesProvidesAdapter extends ProvidesBinding<android.content.SharedPreferences>
      implements Provider<android.content.SharedPreferences> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideDefaultSharedPreferencesProvidesAdapter(AndroidModule module) {
      super("android.content.SharedPreferences", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideDefaultSharedPreferences");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.content.SharedPreferences>}.
     */
    @Override
    public android.content.SharedPreferences get() {
      return module.provideDefaultSharedPreferences(context.get());
    }
  }

  /**
   * A {@code Binding<android.telephony.TelephonyManager>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.telephony.TelephonyManager} and its
   * dependencies.
   *
   * Being a {@code Provider<android.telephony.TelephonyManager>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideTelephonyManagerProvidesAdapter extends ProvidesBinding<android.telephony.TelephonyManager>
      implements Provider<android.telephony.TelephonyManager> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideTelephonyManagerProvidesAdapter(AndroidModule module) {
      super("android.telephony.TelephonyManager", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideTelephonyManager");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.telephony.TelephonyManager>}.
     */
    @Override
    public android.telephony.TelephonyManager get() {
      return module.provideTelephonyManager(context.get());
    }
  }

  /**
   * A {@code Binding<android.accounts.AccountManager>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.accounts.AccountManager} and its
   * dependencies.
   *
   * Being a {@code Provider<android.accounts.AccountManager>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideAccountManagerProvidesAdapter extends ProvidesBinding<android.accounts.AccountManager>
      implements Provider<android.accounts.AccountManager> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideAccountManagerProvidesAdapter(AndroidModule module) {
      super("android.accounts.AccountManager", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideAccountManager");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.accounts.AccountManager>}.
     */
    @Override
    public android.accounts.AccountManager get() {
      return module.provideAccountManager(context.get());
    }
  }

  /**
   * A {@code Binding<android.app.NotificationManager>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.app.NotificationManager} and its
   * dependencies.
   *
   * Being a {@code Provider<android.app.NotificationManager>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideNotificationManagerProvidesAdapter extends ProvidesBinding<android.app.NotificationManager>
      implements Provider<android.app.NotificationManager> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideNotificationManagerProvidesAdapter(AndroidModule module) {
      super("android.app.NotificationManager", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideNotificationManager");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.app.NotificationManager>}.
     */
    @Override
    public android.app.NotificationManager get() {
      return module.provideNotificationManager(context.get());
    }
  }

  /**
   * A {@code Binding<android.content.pm.ApplicationInfo>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.content.pm.ApplicationInfo} and its
   * dependencies.
   *
   * Being a {@code Provider<android.content.pm.ApplicationInfo>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideApplicationInfoProvidesAdapter extends ProvidesBinding<android.content.pm.ApplicationInfo>
      implements Provider<android.content.pm.ApplicationInfo> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideApplicationInfoProvidesAdapter(AndroidModule module) {
      super("android.content.pm.ApplicationInfo", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideApplicationInfo");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.content.pm.ApplicationInfo>}.
     */
    @Override
    public android.content.pm.ApplicationInfo get() {
      return module.provideApplicationInfo(context.get());
    }
  }

  /**
   * A {@code Binding<android.view.inputmethod.InputMethodManager>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.view.inputmethod.InputMethodManager} and its
   * dependencies.
   *
   * Being a {@code Provider<android.view.inputmethod.InputMethodManager>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideInputMethodManagerProvidesAdapter extends ProvidesBinding<android.view.inputmethod.InputMethodManager>
      implements Provider<android.view.inputmethod.InputMethodManager> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideInputMethodManagerProvidesAdapter(AndroidModule module) {
      super("android.view.inputmethod.InputMethodManager", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideInputMethodManager");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.view.inputmethod.InputMethodManager>}.
     */
    @Override
    public android.view.inputmethod.InputMethodManager get() {
      return module.provideInputMethodManager(context.get());
    }
  }

  /**
   * A {@code Binding<android.content.Context>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Being a {@code Provider<android.content.Context>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideAppContextProvidesAdapter extends ProvidesBinding<android.content.Context>
      implements Provider<android.content.Context> {
    private final AndroidModule module;

    public ProvideAppContextProvidesAdapter(AndroidModule module) {
      super("android.content.Context", IS_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideAppContext");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.content.Context>}.
     */
    @Override
    public android.content.Context get() {
      return module.provideAppContext();
    }
  }

  /**
   * A {@code Binding<java.lang.ClassLoader>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code java.lang.ClassLoader} and its
   * dependencies.
   *
   * Being a {@code Provider<java.lang.ClassLoader>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvideClassLoaderProvidesAdapter extends ProvidesBinding<ClassLoader>
      implements Provider<ClassLoader> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvideClassLoaderProvidesAdapter(AndroidModule module) {
      super("java.lang.ClassLoader", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "provideClassLoader");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<java.lang.ClassLoader>}.
     */
    @Override
    public ClassLoader get() {
      return module.provideClassLoader(context.get());
    }
  }

  /**
   * A {@code Binding<android.content.pm.PackageInfo>} implementation which satisfies
   * Dagger's infrastructure requirements including:
   *
   * Owning the dependency links between {@code android.content.pm.PackageInfo} and its
   * dependencies.
   *
   * Being a {@code Provider<android.content.pm.PackageInfo>} and handling creation and
   * preparation of object instances.
   */
  public static final class ProvidePackageInfoProvidesAdapter extends ProvidesBinding<android.content.pm.PackageInfo>
      implements Provider<android.content.pm.PackageInfo> {
    private final AndroidModule module;
    private Binding<android.content.Context> context;

    public ProvidePackageInfoProvidesAdapter(AndroidModule module) {
      super("android.content.pm.PackageInfo", NOT_SINGLETON, "com.sjtu.icarer.AndroidModule", "providePackageInfo");
      this.module = module;
      setLibrary(true);
    }

    /**
     * Used internally to link bindings/providers together at run time
     * according to their dependency graph.
     */
    @Override
    @SuppressWarnings("unchecked")
    public void attach(Linker linker) {
      context = (Binding<android.content.Context>) linker.requestBinding("android.content.Context", AndroidModule.class, getClass().getClassLoader());
    }

    /**
     * Used internally obtain dependency information, such as for cyclical
     * graph detection.
     */
    @Override
    public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
      getBindings.add(context);
    }

    /**
     * Returns the fully provisioned instance satisfying the contract for
     * {@code Provider<android.content.pm.PackageInfo>}.
     */
    @Override
    public android.content.pm.PackageInfo get() {
      return module.providePackageInfo(context.get());
    }
  }
}
